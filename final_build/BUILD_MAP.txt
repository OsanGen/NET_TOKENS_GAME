Full Build Map â€” NEWGAME (Complete Architecture v2)

System classification
- Product domain: deterministic browser game runtime with custom visual system and enterprise-grade static deployment.
- Runtime trust boundary: all authoritative simulation and draw logic is client-side in `game.js`.
- No backend services, no API credentials, no data persistence layer.

Code footprint snapshot
- Runtime core: `game.js` (single large module, ~198k bytes)
- Shell + presentation: `index.html`, `styles.css`
- Assets: `assets/`
- Tooling: `scripts/`, `output/`, `web_game_playwright_client_local.js`
- Deployment: `.github/workflows/deploy-pages.yml`
- Technical docs: `final_build/*.txt`, `progress.md`

Authoritative entry points
- Browser: `/index.html`
  - Loads visual shell and container DOM.
  - Loads `/styles.css`.
  - Executes `/game.js`.
- Runtime API: `window.render_game_to_text()` and `window.advanceTime(ms)` in `game.js`.
- Inputs: keyboard handlers defined in `game.js`.
- Local launch: `/scripts/open-game.sh`, `/scripts/stop-game.sh`.
- CI/CD entry: `.github/workflows/deploy-pages.yml` (main branch trigger + dispatch).

Repository-level dependency graph (logical)
- `index.html`
  - depends on `styles.css` for tokens, control layout, and motion contracts
  - depends on IDs/classes used by `game.js` for UI sync
- `game.js`
  - depends on DOM container and control nodes declared in `index.html`
  - depends on `styles.css` variables/presets for profile-specific rendering behavior
- `styles.css`
  - depends on semantic IDs/classes generated by `index.html`
- `web_game_playwright_client_local.js`
  - depends on Playwright + exported APIs/DOM contract from `game.js` and `index.html`
- `output/web-game`
  - depends on Playwright run artifacts produced during validation
- `scripts/*`
  - depend on local environment tooling and repository paths
- `.github/workflows/deploy-pages.yml`
  - depends on file set: `index.html`, `game.js`, `styles.css`, `favicon.ico`, `assets/`

Package dependency graph
- `game.js`
  - no runtime dependencies (self-contained game module)
- `web_game_playwright_client_local.js`
  - `@playwright/test` (via `package.json` devDependency)
- `package.json`
  - `playwright: ^1.58.2`
- Shell scripts
  - `/bin/bash`, `python3`, `lsof`, `python3` HTTP serve utilities

Component and responsibility map
- Core Runtime (`game.js`)
  - Deterministic state machine for mode transitions
  - Input interpretation and input edge case handling
  - Simulation update tick for hub, mission, battle, result
  - Health/task/combat checks and victory conditions
  - Full render pass and visual state sync
- Visual Post Process (`game.js`)
  - Scanline and tone control layers
  - VFX pulses and combat impact overlays
  - Motion profile behavior (`reduced`, `minimal`, etc.) applied in render stage
- Visual Shell (`index.html` + `styles.css`)
  - HUD / action rail / telemetry containers
  - Glass panels, command frames, spacing and responsive breakpoints
  - Theme and profile state is visually expressed via body attributes and CSS variables
- Asset Pipeline (`assets/`, `scripts/generate-imagegen-assets.sh`, `tmp/imagegen/`)
  - Authoring and refresh of sprite textures and visual materials
  - Runtime consumption layer remains stable regardless of asset generation tooling
- Local Tooling (`scripts/open-game.sh`, `scripts/stop-game.sh`)
  - Deterministic local server lifecycle
  - Optional browser opening and cleanup
- Deployment (`.github/workflows/deploy-pages.yml`)
  - Builds static artifact from project root runtime files
  - Pushes to Pages without requiring runtime build step

Boundary map (clean contracts)
- Gameplay logic boundary
  - `game.js` is the only place with gameplay truth and math
  - UI layer must not mutate gameplay objects directly
- UI boundary
  - DOM layer is read/write for display only
  - `syncExternalControlsUI()` is the synchronization boundary from state -> UI
- Rendering boundary
- Canvas draw logic and post-process are in `game.js` and use CSS for style policy
- Tooling/deploy boundary
  - External scripts and CI do not alter gameplay algorithms
  - Scripts only orchestrate environment or content generation

Mode-aware data flow
1) Input
  - Event listeners capture intent and map to current mode handlers.
2) Update
  - `update()` advances deterministic state by mode branch.
3) Resolve
  - mission outcomes, combat damage, transitions, timer progression, objective gates.
4) Render
  - scene + entities + overlays -> canvas
5) Post-process
  - pulses, filters, scanline/noise and reduced-motion adjustments
6) Sync
  - external HUD text + controls from canonical state
7) Exposure
  - automation snapshot from `render_game_to_text()`

State management details
- Authoritative mutable state is in-memory only:
  - navigation and phase (`mode`, transitions, locks, cooldowns, timers)
  - actors (player/enemy arrays, positions, HP, statuses)
  - mission tasks (objectives, counters, gating logic)
  - combat stack (action queue, result metadata, side turn)
  - visual controller state (presets, profiles, pulses, motion state)
- All visible UI values are derived from this state each tick.
- No background storage or cross-session persistence exists.

Data model summary
- Visual model:
  - `visual` object: profile/preset, vfx strength, motion intent, pulse values
- Scene model:
  - Scene/brand recipe + tone set + layout identity
- Entity model:
  - Player and enemy state, movement data, HP, action flags
- Combat model:
  - Turn owner, active attack option, damage output, impact meta payload
- Mission model:
  - Objective state, win/lose thresholds, spawn/task timers
- UI model:
  - Action set labels, hints, side rail and bottom rail text

API and integration model
- Public debug APIs (window scope)
  - `render_game_to_text()`: deterministic readout used for botting/automation
  - `advanceTime(ms)`: deterministic stepping without manual key input
- Interaction keys
  - `F`, `V`, `P`, `H`, plus directional + action keys for mode-specific behavior
- DOM integration
  - External control nodes are updated each render cycle from state
  - UI IDs/classes function as the stable interface

Caching and render performance
- No server-side cache.
- Browser caches:
  - assets via standard static file caching
  - decoded image cache and request cache for sprites
- Performance-sensitive stages:
  - per-frame render pass
  - post-process pass
  - frequent DOM sync text updates
- Quality-performance controls:
  - render scale behavior
  - anti-aliasing toggle (`imageSmoothingEnabled`)
  - motion profile gates and clamp on overlay opacity

Logging and failure behavior
- Runtime logs
  - Browser console is the only built-in log channel
- Failure strategy
  - keep frame loop alive when possible
  - degrade to stable UI text when edge state is invalid
  - no crash-on-fail guard unless underlying logic throws
- No external telemetry sink in scope

Security model and trust assumptions
- No auth or secret handling in client runtime.
- Attack surface is static JS execution, DOM event inputs, and browser extension/script injection.
- Integrity relies on static source and GitHub hosting trust.

Build and deploy chain
- `index.html` + `game.js` + `styles.css` + assets loaded by browser.
- Optional local run via scripts.
- Automated publish via GitHub Pages workflow:
  - checkout -> upload artifact -> deploy pages.
- Output: static site with no build compilation phase.

Architecture diagram (data/control edges)
- Browser
  - loads -> `index.html`
  - applies -> `styles.css`
  - executes -> `game.js`
  - captures -> keyboard/input
  - renders -> `<canvas>` + DOM sync
  - consumes -> `render_game_to_text()`
- `game.js`
  - mutates -> in-memory state
  - emits -> canvas frame + DOM updates + API payloads
  - drives -> visual post-processing
- Tooling
  - `web_game_playwright_client_local.js` -> `game.js` APIs/DOM
  - scripts -> local server lifecycle
- CI
  - `.github/workflows/deploy-pages.yml` -> static artifact publish

Technical debt indicators (from current design)
- Single large runtime file (`game.js`) concentrates cross-cutting concerns.
- High coupling between DOM IDs/classes and UI sync logic.
- Some visual and gameplay concerns are still colocated in one module.
- Manual process orchestration via scripts and fixed port assumptions.

Open risks
- DOM contract fragility when changing markup IDs/classes.
- Sprite density and scaling regressions if asset dimensions change without render tuning.
- Visual artifact risks when profile intensity exceeds frame budget.
- No automated integration suite for every branch transition path.

Control and data flow summary
- Controls: user input -> intent flags -> mode resolver -> deterministic update -> rendered state.
- Data: state -> simulation outputs -> render context -> HUD text -> API snapshots -> automation.

Acceptance checkpoints
- Clean mode transitions: title -> hub -> mission -> battle -> result.
- Deterministic API readout remains stable across runs.
- No runtime exceptions in DOM sync path for missing/hidden nodes.
- Playwright smoke path can find key selectors and action rail.
- Reduced-motion/profile variants remain readable and non-flickering.

Deployment outputs
- Demo bundle files: `index.html`, `game.js`, `styles.css`, `favicon.ico`, `assets/*`.
- GitHub Pages endpoint served from repository site path.

Governance / change log guidance
- Runtime logic and UI contract changes must update:
  - `COMPONENT__Core_Runtime.txt`
  - `COMPONENT__Controls_Overlay.txt`
  - `CURRENT_GAPS.txt` if status changes
  - `BUILD_MAP.txt` when boundaries or flows change

Dependency matrix (one-line traceability)
- `index.html` -> `styles.css` (presentation tokens and layouts)
- `index.html` -> `game.js` (bootstraps runtime entrypoint)
- `game.js` -> `index.html` DOM (`#game-shell`, `#game-canvas`, `#controls-*`, action containers)
- `game.js` -> `styles.css` (stateful class / attribute selectors for visual presentation)
- `game.js` -> `assets/*` (runtime sprite/frame reads)
- `game.js` -> `render_game_to_text()` / `advanceTime(ms)` external consumers
- `web_game_playwright_client_local.js` -> `game.js` public API + DOM selectors
- `scripts/open-game.sh` -> local dev server + browser
- `scripts/stop-game.sh` -> local process cleanup
- `.github/workflows/deploy-pages.yml` -> static artifact inputs (`index.html`, `game.js`, `styles.css`, `assets/*`)

Logical package boundaries
- Runtime application package: no external runtime imports (self-sufficient in browser runtime).
- Dev/test package: `playwright` only, isolated to `web_game_playwright_client_local.js`.
- Devops package: shell + GitHub Actions primitives.

Execution sequence (canonical)
1. Developer edits source files.
2. Local run starts using `scripts/open-game.sh`.
3. Browser loads `index.html` and initializes `game.js`.
4. User/session drives mode transitions with keyboard/input.
5. Render cycle emits canvas frame + DOM sync + optional automation snapshot.
6. QA path uses Playwright local client for deterministic smoke checks.
7. Git push to `main`.
8. GitHub Pages workflow publishes static artifact.

Mermaid architecture graph
```mermaid
flowchart LR
  A[index.html] --> B[styles.css]
  A --> C[game.js]
  C --> D[In-memory state]
  C --> E[Input listeners]
  C --> F[Canvas render]
  C --> G[DOM sync: controls/status]
  C --> H[window APIs]
  H --> I[render_game_to_text]
  H --> J[advanceTime]
  F --> K[Visual post-process]
  K --> L[Final frame]
  G --> M[Playwright selectors]
  J --> M
  I --> M
  C --> N[assets/]
  O[scripts/open-game.sh] --> P[local http server]
  P --> A
  Q[.github/workflows/deploy-pages.yml] --> R[GitHub Pages]
  A --> R
```

Mermaid control-plane graph
```mermaid
stateDiagram-v2
    [*] --> Title
    Title --> Hub: Start
    Hub --> Mission: Launch
    Mission --> Battle: Threat trigger
    Battle --> Mission: Win/lose branch
    Mission --> Result: Objective met
    Result --> Hub: Return
    Hub --> [*]: Exit
    Mission --> [*]: Failure
    Battle --> [*]: Failure
```

Build operations checklist
- Pre-deploy:
  - confirm `index.html` references existing IDs/classes expected by `game.js`
  - confirm `styles.css` retains all selectors used by current markup
  - verify `git status` clean for intended commit set
- Deploy:
  - push to `main`
  - Pages workflow publishes updated assets
- Post-deploy:
  - open GitHub Pages endpoint and verify shell + action rails
  - verify controls and mode transitions visually
  - verify public API remains callable (`render_game_to_text`, `advanceTime`)

Risk register (expanded)
- R-01 DOM drift: UI node rename/removal without sync update in runtime.
- R-02 VFX overload: frame pacing regression from high-overhead visual effects.
- R-03 Local port/process conflict: stale local PIDs block quick iteration.
- R-04 Visual inconsistency: reduced-motion path not reflecting design intent.
- R-05 Asset mismatch: regenerated sprite dimensions requiring render scale retune.

Mitigations
- Keep DOM IDs stable and versioned in component docs before edits.
- Limit VFX lifetime and alpha ceiling in normal profile.
- Script checks for running PID and graceful cleanup path.
- Validate reduced-motion and minimal variants after any visual release.
- Tie sprite dimensions to scale constants and verify in hub + mission + battle screens.

Next-doc gap candidates
- Add `final_build/ARCHITECTURE_DATA_FLOW.txt` with explicit event/state schemas.
- Add `final_build/DEPLOY_RUNBOOK.txt` if you want a deploy-only single-page playbook.
