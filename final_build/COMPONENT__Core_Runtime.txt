Component: Core Runtime
Purpose:
Own deterministic simulation/render state progression, deterministic mode transitions, and automation surface for gameplay telemetry and visual compliance.

Entry Points:
- Browser IIFE bootstrap in `game.js` (immediate execution on load).
- `startBtn.click` => `startFromTitle()`.
- Keyboard event listeners via `document.addEventListener('keydown'|'keyup', keyEvent)`.
- Browser resize + blur listeners.
- RAF loop `loop(now)` as the frame scheduler.
- Test/automation hooks: `window.render_game_to_text()` and `window.advanceTime(ms)`.

Module Boundaries:
- State initialization and mutation block (`state`, `input`, `hudNodes`).
- Utility layer: color, RNG, geometry, parse helpers.
- Visual stack:
  - Scene assembly (`drawWorldScene`, `draw...` mode renderers)
  - Post-process and compose (`drawPostProcess`, `resolveActiveVfxProfile`)
  - DOM sync (`syncExternalControlsUI`)
- Game logic block:
  - hub/missions/combat/update loops.
- Asset block:
  - sprite manifest + probe/lifecycle tracking (`initializeSpriteRegistry`, `markSpriteUnavailable`, `spriteStatus`).
- IO block:
  - keyboard actions, resize/blur, fullscreen controls, automation exports.

Inputs:
- User: `Arrow/WASD`, `Space`, `Enter`, `H`, `V`, `P`, `F`, `Escape`.
- DOM: `#game-canvas`, `#start-btn`, `#controls-*` nodes.
- External hooks: `window.innerWidth/Height`, `performance.now()`, browser visibility/fullscreen APIs.
- Deterministic seed/state: `state.seed`, `state.rng`, `state.mode`.

Outputs:
- Rendered frame to canvas in `SIM_W x SIM_H` source pipeline and scaled output.
- Deterministic JSON in `render_game_to_text()` (mode, state, payload, telemetry, brand audit).
- DOM HUD mutations via `hudNodes` + shell attributes.
- Gameplay transitions among `title`, `hub`, `mission`, `battle`, `result`.

Data Models:
- `state`: world + flow state.
  - Player: `x, y, vx, vy, hp, invulnFrames, shootCd, knockbackX, knockbackY, flash, damageStreak, damageDecay`.
  - Mission: `planetId, target, task, encounter, entities, enemyQueue, spawn timers, encounter lock`.
  - Battle: `active, menu, enemyPet, playerPet, log, turn`.
  - Visual: `accentLead, contrastMode, vfxPreset, visualProfile, visualProfileAuto, modeTransition, vfxPulse, battleHud, useVectorFallback`.
  - UI: `helpVisible, helpPinned, autoHelpUntilFrame, firstMissionHelpShown`.
  - Infrastructure state: `frame`, `seed`, `rng`, `player`, `petDex`, `party`, `storage`, `hubs`, `messages`.
- `hudNodes`: cached DOM refs for telemetry sync.
- `spriteRegistry`: per-key image loading with status (`loading`, `ready`, `missing`).
- External telemetry payload from text hook includes `ui.brandAudit` and `assets` counters.

Data Flow:
- `loop(now)` computes frame delta -> accumulator -> one or more fixed timestep `update(1/60)` calls -> `render()`.
- `update(dt)` dispatches mode logic (`updateHub`, `updateMission`, `updateBattle`), processes transitions, pulses decay, mission success checks.
- `render()` selects profile/presets -> resolves scene tone -> draws world scene -> post-process -> HUD sync.
- Inputs are edge- and level-buffered (`setInputDown`) then consumed in mode functions and battle menu code.
- Mode changes via `setMode()` and `startModeTransition()` update gameplay + visual transition metadata for shader/profile blend.

Background Jobs / Timing:
- Continuous RAF loop with fixed-timestep accumulator.
- `setInterval`/`setTimeout` are only used in Playwright helper shim; runtime uses no recurring polling loops.
- `normalizeTransitionFrames` controls transition duration normalization in gameplay mode changes.

State Management:
- State is centralized mutable object mutated in-place every frame.
- Determinism relies on explicit `seed()` + xorshift-style RNG usage per mode and mission seed derivations.
- External resets via `resetGame()`/`resetObjective()`.
- Transient transition state in `state.visual.modeTransition` and top-level `transition` (result-to-hub countdown)
  represent separate concerns: scene blend vs mission-result auto-return.

Caching Layers:
- Sprite cache with `spriteRegistry` and loading counters.
- Render cache surfaces: `scene` and `postFxCanvas` reused each frame.
- Brand/audio-neutral profile cache via `resolveVisualPreset`/`resolveVisualPolicy` call chain.

API Surfaces:
- Exposed runtime hooks: `window.render_game_to_text`, `window.advanceTime`, `window.gameState`.
- No authenticated APIs, network APIs, or backend calls in game runtime.

Logging & Observability:
- Console warnings via `assertSingleAccent` and `assertReadableContrast` emit once-per-runner warnings.
- In-game `messages` queue acts as gameplay log (last entries surfaced in UI + text payload).
- Playwright helper captures console/page errors into `errors-*.json` and optionally halts iteration on first failure.

Error Handling:
- Guarded command inputs with feature presence checks (`if (!state.visual) return`, `if (!targetId) return`, etc.).
- Animation and input handlers fail soft where safe (early returns, bounds checks).
- Modal errors are only escalated through console + render loop continues.
- Known hard failures: invalid asset/probe load falls back to vector rendering paths.

Dependency/Integration Surfaces:
- Browser: Canvas2D, RAF, fullscreen, resize, preferences media query.
- Tooling: `/Users/abelsanchez/CODEX/NEWGAME/web_game_playwright_client_local.js` for deterministic UI smoke.
- Assets: `assets/sprites/*` plus fallback draw code.
- Deploy/build: static HTML/CSS/CANVAS bundle and GitHub Pages workflow.

Acceptance Checks:
- `node --check game.js` and `node --check web_game_playwright_client_local.js` clean.
- Deterministic startup by setting seed and replaying same `advanceTime` path yields identical text payload.
- `space` on title transitions only in title mode; `setMode` transitions cover title/hub/mission/result/battle.
- `render_game_to_text` includes `ui.brandAudit` with live tone/visual profile metrics.
- Playwright smoke path executes with no `errors-*.json` output after script steps.

Determinism controls:
- One source of randomness: `state.rng` and deterministic derivations (`spawnRngFromState`, `pickFromSeed`) at call boundaries.
- Mission and combat randomness must be consumed in a stable order; any refactor must preserve consume sequence.
- Transition timing and pulse lifetimes are frame-based with deterministic clamp logic.
- `advanceTime(ms)` is the primary deterministic stepping API for test reproducibility.

Mode-transition contract:
- `setMode(nextMode)` is the authoritative finite-state transition.
- `startModeTransition(toMode, durationFrames)` writes blend metadata only; state ownership remains in `setMode`.
- Transition IDs increment monotonically and are compared to invalidate stale transition callbacks.
- Any transition into `result` should:
  - cancel pending battle lock states
  - clear battle impact visuals
  - queue HUD/console summary in one frame.
- `resetMissionState` and `startMission` should never run on top of unresolved pending transitions.

Input model and safety:
- `keydown/keyup` pipeline:
  - maps both arrow and WASD/JKL; ignores repeated keydown for edge-only controls.
  - supports action repeats via `input.*` hold where gameplay requires continuous behavior (e.g., `input.space`).
- `keyUp` always clears transient edges (`*Edge`) to avoid phantom confirm/cancel.
- Blur/visibility events clear non-persistent edges and pause visual-only timers where safe.

Performance and timing:
- `loop(now)` uses fixed-step accumulator; if browser stalls beyond maximum delta, integration should cap to avoid unstable catch-up.
- Avoid per-frame allocations in hot update paths (`hudNodes` cache, sprite renderers, and object pooling).
- No setInterval loops in runtime except optional external tooling (keeps deterministic progression).
- Heavy effects branches (`particle`, `noise`, `chromaticBleed`) are profile-gated.

Error and hard-failure strategy:
- Non-blocking runtime faults:
  - unknown mode: fallback to title + warning.
  - invalid mode-specific function: log and noop transition.
  - missing DOM refs: continue simulation + degrade to non-interactive HUD mode.
- Blocking faults:
  - canvas unavailable (0x0): skip draw path, log explicit message, keep state updates paused.
  - malformed payload in `window.gameState` getter: restore canonical defaults.
- Recovery strategy:
  - `resetGame()` should be safe even when called during combat transitions.
  - `window.gameState` remains read-only by convention; runtime does not trust external mutation.

Observability:
- Smoke telemetry from `render_game_to_text()` should include at least:
  - `state.mode`, `state.frame`, `state.seed`
  - `state.transitionProgress` if transitioning
  - `state.visual.motionState`
  - `state.messageCount`
- Optional debug flag:
  - `window.DEBUG_RUNTIME_LOOP`: when true, emit deterministic frame-level heartbeat every N frames.
- Ensure console noise is deduplicated (same warning printed once per session when possible).

Failure-mode checklist:
- Transition race:
  - if mode changes twice in one frame, ensure newest mode wins and stale transition UI callbacks are ignored.
- Replay mismatch:
  - same seed + same input script + same advanceTime intervals must produce stable `render_game_to_text()` snapshots.
- Browser resize storm:
  - repeated resize should not recreate display canvases; should only recompute CSS dimensions and scaling.
- Input desync:
  - stale keydown state after tab-switch/focus-loss should auto-clear non-persistent hold/edge flags.
- Sprite/asset failures:
  - missing visual assets must never break state stepping or transition logic.

Risk controls for refactors:
- Keep runtime and render concerns separated so rendering tweaks do not touch gameplay mutation.
- Centralize any new mode handling through `setMode` and avoid inline mode checks.
- Avoid changing loop timing constants without updating `ENTERPRISE_TEST_MATRIX`.

Maintenance Notes:
- Dead runtime helpers were removed in this pass:
  - `normalizeModeTransition`
  - `biomeAccentToken`
  - `drawHubFocusCard`
  - `drawMissionStatusStrip`
- These were unused and only increased drift risk during future refactors.
